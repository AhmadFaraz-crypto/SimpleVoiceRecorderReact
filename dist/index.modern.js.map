{"version":3,"file":"index.modern.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.mjs","../src/components/useRecorder.ts","../src/components/Recorder.tsx"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { useEffect, useState, useRef, useCallback } from 'react';\n\nexport interface UseRecorderReturn {\n  audioURL: string | null;\n  isRecording: boolean;\n  isPaused: boolean;\n  startRecording: () => Promise<void>;\n  stopRecording: () => void;\n  pauseRecording: () => void;\n  resumeRecording: () => void;\n  clearRecording: () => void;\n  error: string | null;\n  audioBlob: Blob | null;\n}\n\nconst useRecorder = (): UseRecorderReturn => {\n  const [audioURL, setAudioURL] = useState<string | null>(null);\n  const [isRecording, setIsRecording] = useState<boolean>(false);\n  const [isPaused, setIsPaused] = useState<boolean>(false);\n  const [error, setError] = useState<string | null>(null);\n  const [audioBlob, setAudioBlob] = useState<Blob | null>(null);\n  const recorderRef = useRef<InstanceType<typeof MediaRecorder> | null>(null);\n  const streamRef = useRef<MediaStream | null>(null);\n  const chunksRef = useRef<Blob[]>([]);\n\n  const clearRecording = useCallback(() => {\n    setAudioURL(prevURL => {\n      if (prevURL) {\n        URL.revokeObjectURL(prevURL);\n      }\n      return null;\n    });\n    setAudioBlob(null);\n    chunksRef.current = [];\n  }, []);\n\n  const stopRecording = useCallback(() => {\n    if (recorderRef.current && isRecording) {\n      try {\n        if (recorderRef.current.state === 'recording' || recorderRef.current.state === 'paused') {\n          recorderRef.current.stop();\n        }\n        setIsRecording(false);\n        setIsPaused(false);\n      } catch (err) {\n        const errorMessage = err instanceof Error ? err.message : 'Failed to stop recording';\n        setError(errorMessage);\n        console.error('Error stopping recording:', err);\n        setIsRecording(false);\n        setIsPaused(false);\n      }\n    }\n  }, [isRecording]);\n\n  const pauseRecording = useCallback(() => {\n    if (!recorderRef.current) {\n      console.warn('No recorder instance available');\n      return;\n    }\n    \n    try {\n      const recorderState = recorderRef.current.state;\n      \n      if (recorderState === 'recording') {\n        recorderRef.current.pause();\n        setIsPaused(true);\n      } else if (recorderState === 'paused') {\n        setIsPaused(true);\n      } else {\n        console.warn(`MediaRecorder is in '${recorderState}' state, cannot pause`);\n        setError(`Cannot pause: recorder is ${recorderState}`);\n        if (recorderState === 'inactive') {\n          setIsRecording(false);\n          setIsPaused(false);\n        }\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to pause recording';\n      setError(errorMessage);\n      console.error('Error pausing recording:', err);\n      if (recorderRef.current?.state === 'inactive') {\n        setIsRecording(false);\n        setIsPaused(false);\n      }\n    }\n  }, []);\n\n  const resumeRecording = useCallback(() => {\n    if (!recorderRef.current) {\n      console.warn('No recorder instance available');\n      return;\n    }\n    \n    try {\n      const recorderState = recorderRef.current.state;\n      \n      if (recorderState === 'paused') {\n        recorderRef.current.resume();\n        setIsPaused(false);\n      } else if (recorderState === 'recording') {\n        setIsPaused(false);\n      } else {\n        console.warn(`MediaRecorder is in '${recorderState}' state, cannot resume`);\n        setError(`Cannot resume: recorder is ${recorderState}`);\n        if (recorderState === 'inactive') {\n          setIsRecording(false);\n          setIsPaused(false);\n        }\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Failed to resume recording';\n      setError(errorMessage);\n      console.error('Error resuming recording:', err);\n      if (recorderRef.current?.state === 'inactive') {\n        setIsRecording(false);\n        setIsPaused(false);\n      }\n    }\n  }, []);\n\n  const startRecording = useCallback(async () => {\n    if (recorderRef.current) {\n      const currentState = recorderRef.current.state;\n      if (currentState === 'recording') {\n        return;\n      }\n    }\n\n    try {\n      setError(null);\n      \n      if (recorderRef.current) {\n        const currentState = recorderRef.current.state;\n        if (currentState === 'recording' || currentState === 'paused') {\n          try {\n            recorderRef.current.stop();\n            await new Promise(resolve => setTimeout(resolve, 100));\n          } catch (e) {\n            // Ignore errors during cleanup\n          }\n        }\n        recorderRef.current = null;\n      }\n      \n      if (streamRef.current) {\n        streamRef.current.getTracks().forEach(track => track.stop());\n        streamRef.current = null;\n      }\n\n      setAudioURL(prevURL => {\n        if (prevURL) {\n          URL.revokeObjectURL(prevURL);\n        }\n        return null;\n      });\n      setAudioBlob(null);\n      chunksRef.current = [];\n      setIsPaused(false);\n      let stream: MediaStream;\n      try {\n        stream = await navigator.mediaDevices.getUserMedia({ \n          audio: {\n            echoCancellation: true,\n            noiseSuppression: true,\n            autoGainControl: true,\n          } \n        });\n      } catch (getUserMediaError) {\n        throw new Error(`Microphone access denied: ${getUserMediaError instanceof Error ? getUserMediaError.message : 'Unknown error'}`);\n      }\n      \n      if (!stream || stream.getTracks().length === 0) {\n        throw new Error('Failed to get audio stream');\n      }\n\n      const initialAudioTrack = stream.getAudioTracks()[0];\n      if (!initialAudioTrack || initialAudioTrack.readyState !== 'live') {\n        stream.getTracks().forEach(track => track.stop());\n        throw new Error('Audio track is not active');\n      }\n\n      streamRef.current = stream;\n\n      let mediaRecorder: InstanceType<typeof MediaRecorder> | null = null;\n      let selectedMimeType: string | undefined = undefined;\n      \n      const mimeTypes = [\n        'audio/webm',\n        'audio/webm;codecs=opus',\n        'audio/mp4',\n        'audio/ogg;codecs=opus',\n        'audio/wav',\n      ];\n      \n      for (const mimeType of mimeTypes) {\n        if (MediaRecorder.isTypeSupported(mimeType)) {\n          selectedMimeType = mimeType;\n          break;\n        }\n      }\n      \n      if (selectedMimeType) {\n        try {\n          mediaRecorder = new MediaRecorder(stream, { mimeType: selectedMimeType });\n        } catch (createError) {\n          console.warn('Failed to create MediaRecorder with mimeType', selectedMimeType, ':', createError);\n          mediaRecorder = null;\n        }\n      }\n      \n      if (!mediaRecorder) {\n        try {\n          mediaRecorder = new MediaRecorder(stream);\n        } catch (fallbackError) {\n          stream.getTracks().forEach(track => track.stop());\n          throw new Error(`Failed to create MediaRecorder: ${fallbackError instanceof Error ? fallbackError.message : 'Unknown error'}`);\n        }\n      }\n      \n      if (!mediaRecorder) {\n        stream.getTracks().forEach(track => track.stop());\n        throw new Error('Failed to create MediaRecorder: unexpected error');\n      }\n\n      chunksRef.current = [];\n      const handleDataAvailable = (event: BlobEvent) => {\n        if (event.data && event.data.size > 0) {\n          chunksRef.current.push(event.data);\n        }\n      };\n\n      const handleStop = () => {\n        const currentRecorder = recorderRef.current;\n        if (!currentRecorder) {\n          return;\n        }\n        \n        if (chunksRef.current.length > 0) {\n          const blob = new Blob(chunksRef.current, { \n            type: currentRecorder.mimeType || 'audio/webm' \n          });\n          setAudioBlob(blob);\n          const url = URL.createObjectURL(blob);\n          setAudioURL(url);\n        } else {\n          if (currentRecorder.state === 'inactive') {\n            setIsRecording(false);\n            setIsPaused(false);\n          }\n          return;\n        }\n        \n        setIsRecording(false);\n        setIsPaused(false);\n        \n        if (streamRef.current) {\n          streamRef.current.getTracks().forEach(track => track.stop());\n          streamRef.current = null;\n        }\n        \n        recorderRef.current = null;\n      };\n\n      const handleError = (event: Event) => {\n        const currentRecorder = recorderRef.current;\n        if (!currentRecorder) return;\n        \n        const errorEvent = event as MediaRecorderErrorEvent;\n        const errorMessage = errorEvent.error?.message || 'Recording error occurred';\n        console.error('MediaRecorder error:', errorMessage);\n        \n        setError(errorMessage);\n        \n        if (currentRecorder.state === 'recording' || currentRecorder.state === 'paused') {\n          setIsRecording(false);\n          setIsPaused(false);\n          \n          if (streamRef.current) {\n            streamRef.current.getTracks().forEach(track => track.stop());\n            streamRef.current = null;\n          }\n          recorderRef.current = null;\n        }\n      };\n\n      mediaRecorder.ondataavailable = handleDataAvailable;\n      mediaRecorder.onstop = handleStop;\n      mediaRecorder.onerror = handleError;\n\n      recorderRef.current = mediaRecorder;\n      \n      const initialState = mediaRecorder.state;\n      if (initialState !== 'inactive') {\n        stream.getTracks().forEach(track => track.stop());\n        recorderRef.current = null;\n        throw new Error(`Cannot start: MediaRecorder is in '${initialState}' state`);\n      }\n\n      if (!stream.active || stream.getTracks().length === 0) {\n        stream.getTracks().forEach(track => track.stop());\n        recorderRef.current = null;\n        throw new Error('Stream is not active, cannot start recording');\n      }\n\n      const trackBeforeStart = stream.getAudioTracks()[0];\n      if (!trackBeforeStart || trackBeforeStart.readyState !== 'live') {\n        stream.getTracks().forEach(track => track.stop());\n        recorderRef.current = null;\n        throw new Error(`Audio track is not live. State: ${trackBeforeStart?.readyState || 'missing'}`);\n      }\n\n      let startSuccess = false;\n      let startError: Error | null = null;\n      \n      try {\n        mediaRecorder.start();\n        startSuccess = true;\n      } catch (noTimesliceError) {\n        startError = noTimesliceError instanceof Error ? noTimesliceError : new Error('Unknown error');\n        \n        try {\n          mediaRecorder.start(1000);\n          startSuccess = true;\n          startError = null;\n        } catch (timesliceError) {\n          console.error('Failed to start MediaRecorder:', timesliceError);\n          startError = timesliceError instanceof Error ? timesliceError : new Error('Unknown error');\n        }\n      }\n      \n      if (!startSuccess) {\n        stream.getTracks().forEach(track => track.stop());\n        recorderRef.current = null;\n        const errorMsg = startError?.message || 'Unknown error';\n        const errorName = startError instanceof DOMException ? startError.name : 'Unknown';\n        throw new Error(`Failed to start MediaRecorder: ${errorName} - ${errorMsg}`);\n      }\n      \n      setIsRecording(true);\n      setIsPaused(false);\n      \n      await new Promise(resolve => setTimeout(resolve, 150));\n      const finalState = mediaRecorder.state;\n      \n      if (finalState !== 'recording') {\n        if (finalState === 'inactive') {\n          const streamStillValid = stream.active && \n                                   stream.getTracks().length > 0 && \n                                   stream.getAudioTracks()[0]?.readyState === 'live';\n          \n          if (!streamStillValid) {\n            // Stream invalid, go straight to fresh stream recovery\n          } else {\n            try {\n              if (recorderRef.current) {\n                try {\n                  if (recorderRef.current.state !== 'inactive') {\n                    recorderRef.current.stop();\n                  }\n                } catch (e) {\n                  // Ignore cleanup errors\n                }\n                recorderRef.current = null;\n              }\n              \n              const freshRecorder = new MediaRecorder(stream);\n              freshRecorder.ondataavailable = handleDataAvailable;\n              freshRecorder.onstop = handleStop;\n              freshRecorder.onerror = handleError;\n              \n              const freshState = freshRecorder.state as string;\n              if (freshState !== 'inactive') {\n                throw new Error(`Fresh MediaRecorder is not in inactive state: ${freshState}`);\n              }\n              \n              try {\n                freshRecorder.start();\n              } catch (startError) {\n                freshRecorder.start(1000);\n              }\n              \n              await new Promise(resolve => setTimeout(resolve, 150));\n              \n              if (freshRecorder.state === 'recording') {\n                recorderRef.current = freshRecorder;\n                return;\n              }\n            } catch (recoveryError) {\n              // Continue to fresh stream recovery\n            }\n          }\n          \n          try {\n            if (recorderRef.current) {\n              try {\n                if (recorderRef.current.state !== 'inactive') {\n                  recorderRef.current.stop();\n                }\n              } catch (e) {\n                // Ignore cleanup errors\n              }\n              recorderRef.current = null;\n            }\n            \n            if (streamRef.current && streamRef.current !== stream) {\n              streamRef.current.getTracks().forEach(track => track.stop());\n            }\n            if (stream && stream.active) {\n              stream.getTracks().forEach(track => track.stop());\n            }\n            \n            const freshStream = await navigator.mediaDevices.getUserMedia({ \n              audio: {\n                echoCancellation: true,\n                noiseSuppression: true,\n                autoGainControl: true,\n              } \n            });\n            \n            if (!freshStream || !freshStream.active || freshStream.getTracks().length === 0) {\n              throw new Error('Failed to get fresh stream');\n            }\n            \n            const freshAudioTrack = freshStream.getAudioTracks()[0];\n            if (!freshAudioTrack || freshAudioTrack.readyState !== 'live') {\n              freshStream.getTracks().forEach(track => track.stop());\n              throw new Error(`Fresh stream audio track is not live. State: ${freshAudioTrack?.readyState || 'missing'}`);\n            }\n            \n            const finalRecorder = new MediaRecorder(freshStream);\n            finalRecorder.ondataavailable = handleDataAvailable;\n            finalRecorder.onstop = handleStop;\n            finalRecorder.onerror = handleError;\n            \n            streamRef.current = freshStream;\n            \n            try {\n              finalRecorder.start();\n            } catch (startError) {\n              finalRecorder.start(1000);\n            }\n            \n            await new Promise(resolve => setTimeout(resolve, 150));\n            \n            if (finalRecorder.state === 'recording') {\n              recorderRef.current = finalRecorder;\n              chunksRef.current = [];\n              return;\n            } else {\n              throw new Error(`Final recovery failed. State: ${finalRecorder.state}`);\n            }\n          } catch (finalError) {\n            setIsRecording(false);\n            setIsPaused(false);\n            if (streamRef.current) {\n              streamRef.current.getTracks().forEach(track => track.stop());\n              streamRef.current = null;\n            }\n            recorderRef.current = null;\n            throw new Error(`MediaRecorder failed to start after all recovery attempts. Final error: ${finalError instanceof Error ? finalError.message : 'Unknown error'}`);\n          }\n        }\n      }\n      \n    } catch (err) {\n      const errorMessage = err instanceof Error \n        ? err.message \n        : 'Failed to start recording';\n      setError(errorMessage);\n      setIsRecording(false);\n      setIsPaused(false);\n      \n      if (streamRef.current) {\n        streamRef.current.getTracks().forEach(track => track.stop());\n        streamRef.current = null;\n      }\n      if (recorderRef.current) {\n        recorderRef.current = null;\n      }\n    }\n  }, []);\n\n  useEffect(() => {\n    return () => {\n      if (recorderRef.current) {\n        try {\n          const state = recorderRef.current.state;\n          if (state === 'recording' || state === 'paused') {\n            recorderRef.current.stop();\n          }\n        } catch (e) {\n          // Ignore errors during cleanup\n        }\n      }\n      if (streamRef.current) {\n        streamRef.current.getTracks().forEach(track => track.stop());\n      }\n      if (audioURL) {\n        URL.revokeObjectURL(audioURL);\n      }\n    };\n  }, []);\n\n  return {\n    audioURL,\n    isRecording,\n    isPaused,\n    startRecording,\n    stopRecording,\n    pauseRecording,\n    resumeRecording,\n    clearRecording,\n    error,\n    audioBlob,\n  };\n};\n\nexport default useRecorder;\n\n","import React, { useState, useEffect, useRef } from 'react';\nimport useRecorder, { UseRecorderReturn } from './useRecorder';\nimport styles from '../styles.module.scss';\n\nexport interface RecorderProps {\n  blobUrl?: (url: string | null) => void;\n  showAudioPlayUI?: boolean;\n  title?: string;\n  className?: string;\n  hideAudioTitle?: boolean;\n  status?: (status: 'idle' | 'recording' | 'paused' | 'completed' | 'error') => void;\n  onRecordingStart?: () => void;\n  onRecordingStop?: () => void;\n  onRecordingPause?: () => void;\n  onRecordingResume?: () => void;\n  maxDuration?: number; // in seconds, 0 = unlimited\n  showDownloadButton?: boolean;\n  showPauseButton?: boolean;\n  showClearButton?: boolean;\n  downloadFileName?: string;\n  disabled?: boolean;\n}\n\nconst Recorder: React.FC<RecorderProps> = ({\n  blobUrl,\n  showAudioPlayUI = true,\n  title = '',\n  className = '',\n  hideAudioTitle = false,\n  status,\n  onRecordingStart,\n  onRecordingStop,\n  onRecordingPause,\n  onRecordingResume,\n  maxDuration = 0,\n  showDownloadButton = true,\n  showPauseButton = true,\n  showClearButton = true,\n  downloadFileName = 'recording',\n  disabled = false,\n}) => {\n  // Hooks must be called unconditionally at the top level\n  const {\n    audioURL,\n    isRecording,\n    isPaused,\n    startRecording,\n    stopRecording,\n    pauseRecording,\n    resumeRecording,\n    clearRecording,\n    error,\n    audioBlob,\n  } = useRecorder();\n\n  const [seconds, setSeconds] = useState<number>(0);\n  const [minutes, setMinutes] = useState<number>(0);\n  const [hours, setHours] = useState<number>(0);\n  const intervalRef = useRef<number | null>(null);\n  const totalSecondsRef = useRef<number>(0);\n\n  // Timer effect\n  useEffect(() => {\n    if (isRecording && !isPaused) {\n      intervalRef.current = window.setInterval(() => {\n        totalSecondsRef.current += 1;\n        \n        // Check max duration\n        if (maxDuration > 0 && totalSecondsRef.current >= maxDuration) {\n          stopRecording();\n          return;\n        }\n\n        setSeconds(prevSeconds => {\n          const newSeconds = prevSeconds + 1;\n          if (newSeconds === 60) {\n            setMinutes(prevMinutes => {\n              const newMinutes = prevMinutes + 1;\n              if (newMinutes === 60) {\n                setHours(prevHours => prevHours + 1);\n                return 0;\n              }\n              return newMinutes;\n            });\n            return 0;\n          }\n          return newSeconds;\n        });\n      }, 1000);\n    } else {\n      if (intervalRef.current !== null) {\n        window.clearInterval(intervalRef.current);\n        intervalRef.current = null;\n      }\n    }\n\n    return () => {\n      if (intervalRef.current !== null) {\n        window.clearInterval(intervalRef.current);\n        intervalRef.current = null;\n      }\n    };\n  }, [isRecording, isPaused, maxDuration, stopRecording]);\n\n  // Reset timer when recording stops\n  useEffect(() => {\n    if (!isRecording && !audioURL) {\n      setSeconds(0);\n      setMinutes(0);\n      setHours(0);\n      totalSecondsRef.current = 0;\n    }\n  }, [isRecording, audioURL]);\n\n  // Handle status callbacks\n  useEffect(() => {\n    if (status) {\n      if (error) {\n        status('error');\n      } else if (isRecording && isPaused) {\n        status('paused');\n      } else if (isRecording) {\n        status('recording');\n      } else if (audioURL) {\n        status('completed');\n      } else {\n        status('idle');\n      }\n    }\n  }, [status, isRecording, isPaused, audioURL, error]);\n\n  // Notify parent of audio URL\n  useEffect(() => {\n    if (blobUrl && audioURL) {\n      blobUrl(audioURL);\n    }\n  }, [audioURL]); // Only depend on audioURL, not blobUrl to prevent infinite loops\n\n  const handleStartRecording = async () => {\n    if (disabled) return;\n    await startRecording();\n    onRecordingStart?.();\n  };\n\n  const handleStopRecording = () => {\n    if (disabled) return;\n    stopRecording();\n    onRecordingStop?.();\n  };\n\n  const handlePauseRecording = () => {\n    if (disabled) return;\n    pauseRecording();\n    onRecordingPause?.();\n  };\n\n  const handleResumeRecording = () => {\n    if (disabled) return;\n    resumeRecording();\n    onRecordingResume?.();\n  };\n\n  const handleClearRecording = () => {\n    if (disabled) return;\n    clearRecording();\n    setSeconds(0);\n    setMinutes(0);\n    setHours(0);\n    totalSecondsRef.current = 0;\n  };\n\n  const handleDownload = () => {\n    if (!audioBlob || disabled) return;\n    \n    const url = URL.createObjectURL(audioBlob);\n    const link = document.createElement('a');\n    link.href = url;\n    link.download = `${downloadFileName}.${audioBlob.type.includes('webm') ? 'webm' : 'mp4'}`;\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n    URL.revokeObjectURL(url);\n  };\n\n  const formatTime = (h: number, m: number, s: number): string => {\n    return `${h < 10 ? `0${h}` : h}:${m < 10 ? `0${m}` : m}:${s < 10 ? `0${s}` : s}`;\n  };\n\n  // Create a safe styles object with fallbacks\n  // Ensure styles is always a valid object with all required properties\n  const safeStyles: Record<string, string> = (styles && typeof styles === 'object' && !Array.isArray(styles)) \n    ? {\n        container: (styles as any).container || '',\n        title: (styles as any).title || '',\n        counter: (styles as any).counter || '',\n        error: (styles as any).error || '',\n        recordingBtn: (styles as any).recordingBtn || '',\n        audioPlay: (styles as any).audioPlay || '',\n        audioPlayer: (styles as any).audioPlayer || '',\n        button: (styles as any).button || '',\n        stopButton: (styles as any).stopButton || '',\n        pauseButton: (styles as any).pauseButton || '',\n        downloadButton: (styles as any).downloadButton || '',\n        clearButton: (styles as any).clearButton || '',\n        actions: (styles as any).actions || '',\n      }\n    : {\n        container: '',\n        title: '',\n        counter: '',\n        error: '',\n        recordingBtn: '',\n        audioPlay: '',\n        audioPlayer: '',\n        button: '',\n        stopButton: '',\n        pauseButton: '',\n        downloadButton: '',\n        clearButton: '',\n        actions: '',\n      };\n\n  const containerClasses = `${safeStyles.container || ''} ${className || ''}`.trim();\n\n  return (\n    <div className={containerClasses} role=\"region\" aria-label=\"Audio Recorder\">\n      {!hideAudioTitle && (\n        <h3 className={safeStyles.title}>\n          {title || 'Audio Recorder'}\n        </h3>\n      )}\n\n      {error && (\n        <div className={safeStyles.error} role=\"alert\" aria-live=\"polite\">\n          {error}\n        </div>\n      )}\n\n      <div className={safeStyles.counter} aria-live=\"polite\" aria-atomic=\"true\">\n        {formatTime(hours, minutes, seconds)}\n      </div>\n\n      <div className={safeStyles.recordingBtn}>\n        {!isRecording && !audioURL && (\n          <button\n            type=\"button\"\n            onClick={handleStartRecording}\n            className={safeStyles.button}\n            disabled={disabled}\n            aria-label=\"Start recording\"\n            tabIndex={0}\n          >\n            Start Recording\n          </button>\n        )}\n\n        {isRecording && (\n          <React.Fragment>\n            <button\n              type=\"button\"\n              onClick={handleStopRecording}\n              className={`${safeStyles.button} ${safeStyles.stopButton}`}\n              disabled={disabled}\n              aria-label=\"Stop recording\"\n              tabIndex={0}\n            >\n              Stop Recording\n            </button>\n            {showPauseButton && (\n              <button\n                type=\"button\"\n                onClick={isPaused ? handleResumeRecording : handlePauseRecording}\n                className={`${safeStyles.button} ${safeStyles.pauseButton}`}\n                disabled={disabled}\n                aria-label={isPaused ? 'Resume recording' : 'Pause recording'}\n                tabIndex={0}\n              >\n                {isPaused ? 'Resume Recording' : 'Pause Recording'}\n              </button>\n            )}\n          </React.Fragment>\n        )}\n\n        {audioURL && (\n          <React.Fragment>\n            {showAudioPlayUI && (\n              <div className={safeStyles.audioPlay}>\n                <audio\n                  controls\n                  src={audioURL}\n                  className={safeStyles.audioPlayer}\n                  aria-label=\"Recorded audio playback\"\n                >\n                  Your browser does not support the audio element.\n                </audio>\n              </div>\n            )}\n\n            <div className={safeStyles.actions}>\n              {showDownloadButton && (\n                <button\n                  type=\"button\"\n                  onClick={handleDownload}\n                  className={`${safeStyles.button} ${safeStyles.downloadButton}`}\n                  disabled={disabled}\n                  aria-label=\"Download recording\"\n                  tabIndex={0}\n                >\n                  Download\n                </button>\n              )}\n\n              {showClearButton && (\n                <button\n                  type=\"button\"\n                  onClick={handleClearRecording}\n                  className={`${safeStyles.button} ${safeStyles.clearButton}`}\n                  disabled={disabled}\n                  aria-label=\"Clear recording\"\n                  tabIndex={0}\n                >\n                  Clear\n                </button>\n              )}\n\n              <button\n                type=\"button\"\n                onClick={handleStartRecording}\n                className={safeStyles.button}\n                disabled={disabled}\n                aria-label=\"Start new recording\"\n                tabIndex={0}\n              >\n                Record Again\n              </button>\n            </div>\n          </React.Fragment>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default Recorder;\n\n"],"names":["useRecorder","_useState","useState","audioURL","setAudioURL","_useState2","isRecording","setIsRecording","_useState3","isPaused","setIsPaused","_useState4","error","setError","_useState5","audioBlob","setAudioBlob","recorderRef","useRef","streamRef","chunksRef","clearRecording","useCallback","prevURL","URL","revokeObjectURL","current","stopRecording","state","stop","err","errorMessage","Error","message","console","pauseRecording","warn","recorderState","pause","_recorderRef$current","resumeRecording","resume","_recorderRef$current2","startRecording","currentState","Promise","resolve","_catch","_temp9","_exit","_temp7","_result","stream","getTracks","length","initialAudioTrack","getAudioTracks","readyState","forEach","track","mediaRecorder","selectedMimeType","undefined","mimeTypes","_i","_mimeTypes","mimeType","MediaRecorder","isTypeSupported","createError","fallbackError","handleDataAvailable","event","data","size","push","handleStop","currentRecorder","blob","Blob","type","url","createObjectURL","handleError","errorEvent","_errorEvent$error","ondataavailable","onstop","onerror","initialState","active","trackBeforeStart","startSuccess","startError","start","noTimesliceError","timesliceError","_startError","errorMsg","errorName","DOMException","name","setTimeout","then","_exit2","finalState","_stream$getAudioTrack","_temp0","_result3","e","navigator","mediaDevices","getUserMedia","audio","echoCancellation","noiseSuppression","autoGainControl","freshStream","freshAudioTrack","finalRecorder","finalError","streamStillValid","_temp1","freshRecorder","freshState","_temp6","_navigator$mediaDevic","getUserMediaError","_temp8","_temp10","_temp11","_temp12","reject","useEffect","Recorder","_ref","blobUrl","_ref$showAudioPlayUI","showAudioPlayUI","_ref$title","title","_ref$className","className","_ref$hideAudioTitle","hideAudioTitle","status","onRecordingStart","onRecordingStop","onRecordingPause","onRecordingResume","_ref$maxDuration","maxDuration","_ref$showDownloadButt","showDownloadButton","_ref$showPauseButton","showPauseButton","_ref$showClearButton","showClearButton","_ref$downloadFileName","downloadFileName","_ref$disabled","disabled","_useRecorder","seconds","setSeconds","minutes","setMinutes","hours","setHours","intervalRef","totalSecondsRef","window","setInterval","prevSeconds","newSeconds","prevMinutes","newMinutes","prevHours","clearInterval","handleStartRecording","handleStopRecording","handlePauseRecording","handleResumeRecording","handleClearRecording","handleDownload","link","document","createElement","href","download","includes","body","appendChild","click","removeChild","formatTime","h","m","s","safeStyles","styles","Array","isArray","container","counter","recordingBtn","audioPlay","audioPlayer","button","stopButton","pauseButton","downloadButton","clearButton","actions","containerClasses","trim","React","role","onClick","tabIndex","Fragment","controls","src"],"mappings":"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"}